# docs.login.xyz llms.txt

> Offering resources and guidance for integrating Sign-In with Ethereum, enhancing user control over digital identities in web applications, while promoting best practices and supporting community involvement within the Ethereum ecosystem.

Sign-In with EthereumYour Keys, Your IdentifierNextQuickstart GuideLast updated 3 years ago

Your Keys, Your Identifier

Last updated 3 years ago

Sign-In with Ethereum is a new form of authentication that enables users to control their digital identity with their Ethereum account and ENS profile instead of relying on a traditional intermediary. Already used throughout Web3, this effort standardizes the method with best practices and makes it easy to adopt securely.

To hop right in, check out our Quickstart Guide.

Sign-in With Ethereum was a standard built collaboratively with the greater Ethereum community. For more information on the EIP, check out the following page:

For more information on Sign-In with Ethereum and its related benefits to both the Web3 ecosystem and Web2 services, check out the following page:

ðŸ’» Login.xyz - Check out the Sign-In with Ethereum home page for more information about supporters, and recent activity.

ðŸ‘¾ Discord - Join the #sign-in-with-ethereum channel in the Spruce Discord Server for additional support.

ðŸ“– Blog - Check out the latest updates on Sign-In with Ethereum posted on the Spruce blog.

We host a Sign-In with Ethereum community where we discuss relevant updates, new libraries, additional integrations, and more. If you're interested in contributing to Sign-In with Ethereum, we encourage that you join the calls by filling in this form.

# Quickstart Guide

Sign-In with EthereumQuickstart GuideThis guide will show how to implement Sign-In with Ethereum (SIWE) in a client-server JavaScript web application.PreviousSign-In with EthereumNextCreating SIWE MessagesLast updated 3 years ago

This guide will show how to implement Sign-In with Ethereum (SIWE) in a client-server JavaScript web application.

Requirements

An Ethereum account in the installed MetaMask wallet

The repository for this tutorial can be found here:

# Creating SIWE Messages

Sign-In with EthereumQuickstart GuideCreating SIWE MessagesThis section describes how to generate Sign-In with Ethereum messages and print them to the console.PreviousQuickstart GuideNextImplement the FrontendLast updated 2 years ago

This section describes how to generate Sign-In with Ethereum messages and print them to the console.

Last updated 2 years ago

A completed version of this part can be found in the example repository ().

Creating SIWE messages in JavaScript is straightforward when using the siwe library in npm. To begin, create a new project called siwe-print.

siwe

siwe-print

mkdir siwe-print && cd siwe-print/

yarn init --yes

yarn add siwe ethers

mkdir src/

We can then write the following into ./src/index.js:

./src/index.js

const siwe = require('siwe');

const domain = "localhost";

const origin = "https://localhost/login";

function createSiweMessage (address, statement) {

  const siweMessage = new siwe.SiweMessage({

    domain,

    address,

    statement,

    uri: origin,

    version: '1',

    chainId: '1'

  });

  return siweMessage.prepareMessage();

}

console.log(createSiweMessage(

    "0x6Ee9894c677EFa1c56392e5E7533DE76004C8D94",

    "This is a test statement."

  ));

Now run the example:

node src/index.js

You should see output similar to the following message, with different values for the Nonce and Issued At fields:

localhost wants you to sign in with your Ethereum account:

0x6Ee9894c677EFa1c56392e5E7533DE76004C8D94

This is a test statement.

URI: https://localhost/login

Version: 1

Chain ID: 1

Nonce: oNCEHm5jzQU2WvuBB

Issued At: 2022-01-28T23:28:16.013Z

To learn about all the available fields in a SiweMessage, check out the information in EIP-4361

SiweMessage

The fields we are most interested in for the purposes of this guide are address and statement. address is the Ethereum address which the user is signing in with, and the statement as this will describe to the user what action we wish to perform on their behalf.

address

statement

Often, as in this example, we don't need to do any manipulation of the message, so we can immediately convert it into the textual representation that the user will sign.

00_print

# Implement the Backend

Sign-In with EthereumQuickstart GuideImplement the BackendHere we learn how to build the backend server to handle the user's submission using Express.js.PreviousImplement the FrontendNextConnect the FrontendLast updated 2 years ago

Here we learn how to build the backend server to handle the user's submission using Express.js.

A completed version of this part can be found here (). This example uses only uses the command line in the terminal to print messages, no monitoring of the browser console log is necessary.

The backend server gives the frontend a nonce to include in the SIWE message and also verifies the submission. As such, this basic example only provides two corresponding endpoints:

/nonce to generate the nonce for the interaction via GET request.

/nonce

GET

/verify to verify the submitted SIWE message and signature via POST request.

/verify

POST

While this simple example does not check the nonce during verification, all production implementations should, as demonstrated in the final section .

1. Setup the project directory:

mkdir siwe-backend && cd siwe-backend/

yarn add cors express siwe ethers

2. Make sure that the package.json type is module like the following:

package.json

type

module

{

  "name": "backend",

  "version": "1.0.0",

  "main": "index.js",

  "type": "module",

  "license": "MIT",

  "scripts": {

    "start": "node src/index.js"

  },

  "dependencies": {

    "siwe": "^2.1.4",

    "cors": "^2.8.5",

    "ethers": "^6.3.0",

    "express": "^4.18.2"

  }

3. Populate src/index.js with the following:

src/index.js

import cors from 'cors';

import express from 'express';

import { generateNonce, SiweMessage } from 'siwe';

const app = express();

app.use(express.json());

app.use(cors());

app.get('/nonce', function (_, res) {

    res.setHeader('Content-Type', 'text/plain');

    res.send(generateNonce());

});

app.post('/verify', async function (req, res) {

    const { message, signature } = req.body;

    const siweMessage = new SiweMessage(message);

    try {

        await siweMessage.verify({ signature });

        res.send(true);

    } catch {

        res.send(false);

    }

app.listen(3000);

4. You can run the server with the following command.

yarn start

In a new terminal window, test the /nonce endpoint to make sure the backend is working:

curl 'http://localhost:3000/nonce'

In the same new terminal window, test the /verify endpoint use the following, and ensure the response is true:

true

curl 'http://localhost:3000/verify' \

  -H 'Content-Type: application/json' \

  --data-raw '{"message":"localhost:8080 wants you to sign in with your Ethereum account:\n0x9D85ca56217D2bb651b00f15e694EB7E713637D4\n\nSign in with Ethereum to the app.\n\nURI: http://localhost:8080\nVersion: 1\nChain ID: 1\nNonce: spAsCWHwxsQzLcMzi\nIssued At: 2022-01-29T03:22:26.716Z","signature":"0xe117ad63b517e7b6823e472bf42691c28a4663801c6ad37f7249a1fe56aa54b35bfce93b1e9fa82da7d55bbf0d75ca497843b0702b9dfb7ca9d9c6edb25574c51c"}'

We can verify the received SIWE message by parsing it back into a SiweMessage object (the constructor handles this), assigning the received signature to it and calling the verify method:

verify

message.verify({ signature })

message.verify({ signature }) in the above snippet makes sure that the given signature is correct for the message, ensuring that the Ethereum address within the message produced the matching signature.

In other applications, you may wish to do further verification on other fields in the message, for example asserting that the authority matches the expected domain, or checking that the named address has the authority to access the named URI.

A small example of this is shown later where the nonce attribute is used to track that a given address has signed the message given by the server.

# Connect the Frontend

Sign-In with EthereumQuickstart GuideConnect the FrontendHere we learn how to update the frontend to send the signed messages to the server.PreviousImplement the BackendNextImplement SessionsLast updated 2 years ago

Here we learn how to update the frontend to send the signed messages to the server.

A completed version of the updated frontend can be found here (). This example uses the  to print messages, so it should be actively monitored.

1. Revisit the siwe-frontend directory, stop any running servers, and update src/index.js:

siwe-frontend

src/index.js:

import { BrowserProvider } from 'ethers';

import { SiweMessage } from 'siwe';

const domain = window.location.host;

const origin = window.location.origin;

const provider = new BrowserProvider(window.ethereum);

const BACKEND_ADDR = "http://localhost:3000";

async function createSiweMessage(address, statement) {

    const res = await fetch(`${BACKEND_ADDR}/nonce`);

    const message = new SiweMessage({

        domain,

        address,

        statement,

        uri: origin,

        version: '1',

        chainId: '1',

        nonce: await res.text()

    });

    return message.prepareMessage();

function connectWallet() {

    provider.send('eth_requestAccounts', [])

        .catch(() => console.log('user rejected request'));

let message = null;

let signature = null;

async function signInWithEthereum() {

    const signer = await provider.getSigner();

    message = await createSiweMessage(

        await signer.address,

        'Sign in with Ethereum to the app.'

    );

    console.log(message);

    signature = await signer.signMessage(message);

    console.log(signature);

async function sendForVerification() {

    const res = await fetch(`${BACKEND_ADDR}/verify`, {

        method: "POST",

        headers: {

            'Content-Type': 'application/json',

        },

        body: JSON.stringify({ message, signature }),

    console.log(await res.text());

const connectWalletBtn = document.getElementById('connectWalletBtn');

const siweBtn = document.getElementById('siweBtn');

const verifyBtn = document.getElementById('verifyBtn');

connectWalletBtn.onclick = connectWallet;

siweBtn.onclick = signInWithEthereum;

verifyBtn.onclick = sendForVerification;

2. Update src/index.html:

src/index.html

<!DOCTYPE html>

<html>

<head>

  <meta charset="utf-8" />

  <title>SIWE Quickstart</title>

</head>

<body>

  <div><button id='connectWalletBtn'>Connect wallet</button></div>

  <div><button id='siweBtn'>Sign-in with Ethereum</button></div>

  <div><button id='verifyBtn'>Send for verification</button></div>

</body>

</html>

3. For this last step, you need to have both the frontend and backend running together. Start by running the backend server with the following command from the parent directory:

cd siwe-backend

In a separate terminal, start the frontend by running the following command and visit the URL printed to the console:

cd siwe-frontend

4. Try to Sign-In with Ethereum by visiting the URL printed to the console, connecting your wallet, and signing in. You can now hit the Send for verification button to receive a true in the console.

Send for verification

03_complete_app/frontend

# Implement Sessions

Sign-In with EthereumQuickstart GuideImplement SessionsHere we learn how to implement sessions with Express.js to add the necessary backend security.PreviousConnect the FrontendNextResolve ENS ProfilesLast updated 2 years ago

Here we learn how to implement sessions with Express.js to add the necessary backend security.

A completed version of the updated backend can be found here (). This example uses the  to print messages, so it should be actively monitored.

For additional security against replay attacks, it is not enough for the backend to generate the nonce. It must also be tied to a browser session with the end-user. In the siwe-backend directory, install the following and edit index.js:

siwe-backend

index.js

yarn add express-session

Update src/index.js to the following:

import Session from 'express-session';

app.use(cors({

    origin: 'http://localhost:8080',

    credentials: true,

}))

app.use(Session({

    name: 'siwe-quickstart',

    secret: "siwe-quickstart-secret",

    resave: true,

    saveUninitialized: true,

    cookie: { secure: false, sameSite: true }

}));

app.get('/nonce', async function (req, res) {

    req.session.nonce = generateNonce();

    res.status(200).send(req.session.nonce);

        if (!req.body.message) {

            res.status(422).json({ message: 'Expected prepareMessage object as body.' });

            return;

        }

        let SIWEObject = new SiweMessage(req.body.message);

        const { data: message } = await SIWEObject.verify({ signature: req.body.signature, nonce: req.session.nonce });

        req.session.siwe = message;

        req.session.cookie.expires = new Date(message.expirationTime);

        req.session.save(() => res.status(200).send(true));

    } catch (e) {

        req.session.siwe = null;

        req.session.nonce = null;

        console.error(e);

        switch (e) {

            case ErrorTypes.EXPIRED_MESSAGE: {

                req.session.save(() => res.status(440).json({ message: e.message }));

                break;

            }

            case ErrorTypes.INVALID_SIGNATURE: {

                req.session.save(() => res.status(422).json({ message: e.message }));

            default: {

                req.session.save(() => res.status(500).json({ message: e.message }));

app.get('/personal_information', function (req, res) {

    if (!req.session.siwe) {

        res.status(401).json({ message: 'You have to first sign_in' });

        return;

    console.log("User is authenticated!");

    res.send(`You are authenticated and your address is: ${req.session.siwe.address}`);

This way, the session (req.session) stores the nonce for the initial validation of the message, and once that's done, more can be added. For example, here we store the message's fields, so we can always reference the address of the user.

req.session

A potential extension is to resolve the ENS domain of the user and keep it in the session.

On the client side, the flow is similar to the previous example, except we now need to send cookies with our requests for the session to work. We can add a new endpoint, personal_information, to retrieve the information from the session in place, without having to send the message and signature every time.

personal_information

In the siwe-frontend directory, stop any running instances and populate src/index.js to match the following:

    const res = await fetch(`${BACKEND_ADDR}/nonce`, {

        credentials: 'include',

    const message = await createSiweMessage(

        await signer.getAddress(),

    const signature = await signer.signMessage(message);

        credentials: 'include'

async function getInformation() {

    const res = await fetch(`${BACKEND_ADDR}/personal_information`, {

const infoBtn = document.getElementById('infoBtn');

infoBtn.onclick = getInformation;

Update the siwe-frontend/src/index.html to match the following:

siwe-frontend/src/index.html

  <head>

    <meta charset="utf-8" />

    <title>SIWE Quickstart</title>

  </head>

  <body>

    <div><button id="connectWalletBtn">Connect wallet</button></div>

    <div><button id="siweBtn">Sign-in with Ethereum</button></div>

    <div><button id="infoBtn">Get session information</button></div>

  </body>

4. Try to Sign-In with Ethereum by visiting the URL printed to the console, connecting your wallet, and signing in. You can now hit the Get session information button to receive a message similar to the following in the console:

Get session information

You are authenticated and your address is: 

Refer to  for additional information on how to use express-session in production.

express-session

03_complete_app/backend

# Resolve ENS Profiles

Sign-In with EthereumQuickstart GuideResolve ENS ProfilesHere we learn how to resolve a user's ENS profile data.PreviousImplement SessionsNextResolve NFT HoldingsLast updated 2 years ago

Here we learn how to resolve a user's ENS profile data.

A completed version of the updated frontend can be found here: ().

Now that the application knows the user's connected account, a basic profile can be built using additional information from  if available. Because the frontend is already is using ethers, it is simple to add this functionality and retrieve this data.

frontend

ethers

Update the frontend/src/index.html file to the following:

frontend/src/index.html

  <style>

    .hidden {

      display: none

    table, th, td {

      border: 1px black solid;

    .avatar {

      border-radius: 8px;

      border: 1px solid #ccc;

      width: 20px;

      height: 20px;

  </style>

  <div><button id="connectWalletBtn">Connect wallet</button></div>

  <div><button id="siweBtn">Sign-in with Ethereum</button></div>

  <div><button id="infoBtn">Get session information</button></div>

  <div class="hidden" id="welcome">

  </div>

  <div class="hidden" id="profile">

    <h3>ENS Metadata:</h3>

    <div id="ensLoader"></div>

    <div id="ensContainer" class="hidden">

      <table id="ensTable">

      </table>

    </div> 

  <div class="hidden" id="noProfile">

    No ENS Profile detected.

This will create a table with data based on the user's ENS information if it exists. Otherwise, if there isn't any data, it will remain hidden and a "No ENS Profile detected." message will be displayed.

Finally, we can finish by updating the index.js file to include what's needed.

Update the frontend/src/index.js file to the following:

frontend/src/index.js

const profileElm = document.getElementById('profile');

const noProfileElm = document.getElementById('noProfile');

const welcomeElm = document.getElementById('welcome');

const ensLoaderElm = document.getElementById('ensLoader');

const ensContainerElm = document.getElementById('ensContainer');

const ensTableElm = document.getElementById('ensTable');

let address;

    profileElm.classList = 'hidden';

    noProfileElm.classList = 'hidden';

    welcomeElm.classList = 'hidden';

    address = await signer.getAddress()

    if (!res.ok) {

        console.error(`Failed in getInformation: ${res.statusText}`);

        return 

    displayENSProfile();

    let result = await res.text();

    console.log(result);

    address = result.split(" ")[result.split(" ").length - 1];

async function displayENSProfile() {

    const ensName = await provider.lookupAddress(address);

    if (ensName) {

        profileElm.classList = '';

        welcomeElm.innerHTML = `Hello, ${ensName}`;

        let avatar = await provider.getAvatar(ensName);

        if (avatar) {

            welcomeElm.innerHTML += ` <img class="avatar" src=${avatar}/>`;

        ensLoaderElm.innerHTML = 'Loading...';

        ensTableElm.innerHTML.concat(`<tr><th>ENS Text Key</th><th>Value</th></tr>`);

        const resolver = await provider.getResolver(ensName);

        const keys = ["email", "url", "description", "com.twitter"];

        ensTableElm.innerHTML += `<tr><td>name:</td><td>${ensName}</td></tr>`;

        for (const key of keys)

            ensTableElm.innerHTML += `<tr><td>${key}:</td><td>${await resolver.getText(key)}</td></tr>`;

        ensLoaderElm.innerHTML = '';

        ensContainerElm.classList = '';

    } else {

        welcomeElm.innerHTML = `Hello, ${address}`;

        noProfileElm.classList = '';

    welcomeElm.classList = '';

The above adds a look-up for some ENS metadata (email, url, description and twitter), then converts the result into content that is displayed in the table. Other functionality includes the showing and hiding of UI elements to make the page dynamic.

email

url

description

twitter

By doing this we're grabbing the label to each of the text records for a user's ENS profile, resolving each of them, and placing the result into a basic table.

To see the result, go into frontend and run:

yarn

Then go into backend and run:

backend

And run through the updated example!

Now once the Sign-In with Ethereum flow is complete and there's an ENS profile associated with the account, the ENS name and avatar will appear along with all additional metadata from the profile in a new table.

04_ens_resolution/frontend

# Resolve NFT Holdings

Sign-In with EthereumQuickstart GuideResolve NFT HoldingsHere we learn how to pull information on a users' NFT holdingsPreviousResolve ENS ProfilesNextTypeScriptLast updated 2 years ago

Here we learn how to pull information on a users' NFT holdings

Similar to the ENS look-up, we can also query the user's NFT ownership. In this example, we will display basic information about the user's NFTs in a table, via the . However, this could also be extended to even give the user a visual gallery view of their NFTs once connected. 

First, we need to change index.html to include a new table. We'll use the same structure as in the last chapter, separating the two tables with an <hr> tag:

index.html

<hr>

    table,

    th,

    td {

    </div>

    No ENS Profile Found.

  <div class="hidden" id="nft">

    <h3>NFT Ownership</h3>

    <div id="nftLoader"></div>

    <div id="nftContainer" class="hidden">

      <table id="nftTable">

Next, we'll update the index.js file to reach out to OpenSea's API using the logged-in user's address, then format the output to place the information in the table. If the user has no NFTs, we'll display a "No NFTs found" message in the loader div.

div

const nftElm = document.getElementById('nft');

const nftLoaderElm = document.getElementById('nftLoader');

const nftContainerElm = document.getElementById('nftContainer');

const nftTableElm = document.getElementById('nftTable');

async function getNFTs() {

        let res = await fetch(`https://api.opensea.io/api/v1/assets?owner=${address}`);

        if (!res.ok) {

            throw new Error(res.statusText)

        let body = await res.json();

        if (!body.assets || !Array.isArray(body.assets) || body.assets.length === 0) {

            return []

        return body.assets.map((asset) => {

            let {name, asset_contract, token_id} = asset;

            let {address} = asset_contract;

            return {name, address, token_id};

        });

    } catch (err) {

        console.error(`Failed to resolve nfts: ${err.message}`);

        return [];

async function displayNFTs() {

    nftLoaderElm.innerHTML = 'Loading NFT Ownership...';

    nftElm.classList = '';

    let nfts = await getNFTs();

    if (nfts.length === 0) {

        nftLoaderElm.innerHTML = 'No NFTs found';

    let tableHtml = "<tr><th>Name</th><th>Address</th><th>Token ID</th></tr>";

    nfts.forEach((nft) => {

        tableHtml += `<tr><td>${nft.name}</td><td>${nft.address}</td><td>${nft.token_id}</td></tr>`

    nftTableElm.innerHTML = tableHtml;

    nftContainerElm.classList = '';

    nftLoaderElm.innerHTML = '';

    displayNFTs();

Similar to the previous guide, to see the result, go into frontend and run:

Now, when a user signs in, information on NFT holdings is displayed below the ENS information (if available).

OpenSea's API is a great resource for interacting with NFT data off-chain. Learn more .

05_nft_resolution/frontend

# TypeScript

LibrariesTypeScriptA TypeScript implementation of EIP-4361: Sign In With Ethereum.PreviousResolve NFT HoldingsNextMigrating to v2Last updated 3 years ago

A TypeScript implementation of EIP-4361: Sign In With Ethereum.

The TypeScript implementation of Sign-In with Ethereum can be found here:

Sign-In with Ethereum can be installed as an npm package. For more information and package information, click .

npm

# Migrating to v2

LibrariesTypeScriptMigrating to v2TypeScript v2PreviousTypeScriptNextTypeScript QuickstartLast updated 2 years ago

TypeScript v2

If you are using siwe v1.1.6, we encourage you to update to the latest version (2.1.x). The following guide walks you through how to update your application.

siwe v1.1.6

2.1.x

The function validate(sig, provider) is now deprecated and is replaced by verify(VerifyParams, VerifyOpts). These two new parameters accept the following fields:

validate(sig, provider)

verify(VerifyParams, VerifyOpts)

export interface VerifyParams {

  /** Signature of the message signed by the wallet */

  signature: string;

  /** RFC 4501 dns authority that is requesting the signing. */

  domain?: string;

  /** Randomized token used to prevent replay attacks, at least 8 alphanumeric characters. */

  nonce?: string;

  /**ISO 8601 datetime string of the current time. */

  time?: string;

export interface VerifyOpts {

  /** ethers provider to be used for EIP-1271 validation */

  provider?: providers.Provider;

  /** If the library should reject promises on errors, defaults to false */

  suppressExceptions?: boolean;

The new function makes it easier to match fields automatically - like domain, nonce and match against other TimeDate instead of now (time).

domain

nonce

time

The return type was also modified. It now returns a SiweResponse instead of a SiweMessage, and this new object is defined by the following interface:

SiweResponse

export interface SiweResponse {

  /** Boolean representing if the message was verified with success. */

  success: boolean;

  /** If present `success` MUST be false and will provide extra information on the failure reason. */

  error?: SiweError;

  /** Original message that was verified. */

  data: SiweMessage;

As part of the new API, new error types were introduced to clarify when a message fails verification. These errors are defined at:

More information regarding the rationale behind the API Harmonization and TypeScript v2.0 beta release can be found here:

# TypeScript Quickstart

LibrariesTypeScriptTypeScript QuickstartA Quickstart example using the TypeScript SIWE LibraryPreviousMigrating to v2NextRustLast updated 3 years ago

A Quickstart example using the TypeScript SIWE Library

Goals

Run a Sign-In with Etheruem example locally

Sign-In with Ethereum using a preferred wallet

version 14.0 or higher

First clone the siwe repository from GitHub by running the following command:

git clone https://github.com/spruceid/siwe-notepad

Next, enter the directory and run the example by using the following commands:

cd siwe-notepad

npm install

npm run dev

Finally, visit the example at http://localhost:4361 (or whichever port npm allocated).

Once the example has loaded, sign in with Ethereum by clicking on one of the wallet options, enter some text, and save that text. After disconnecting, try reconnecting to reload that text once the session has been reestablished.

The full example can be found here:

# Rust

LibrariesRustA Rust implementation of EIP-4361: Sign In With Ethereum.PreviousTypeScript QuickstartNextElixirLast updated 2 years ago

A Rust implementation of EIP-4361: Sign In With Ethereum.

The Rust implementation and latest documentation for Sign-In with Ethereum can be found here:

Sign-In with Ethereum can be found on .

# Elixir

LibrariesElixirAn Elixir implementation of EIP-4361: Sign In With Ethereum.PreviousRustNextPythonLast updated 3 years ago

An Elixir implementation of EIP-4361: Sign In With Ethereum.

The Elixir implementation of Sign-In with Ethereum can be found here:

The package can be installed by adding siwe to your list of dependencies in mix.exs:

mix.exs

def deps do

  [

    {:siwe, "~> 0.3"}

  ]

end

To see how this works in iex, clone this repository and from the root run:

iex

$ mix deps.get

Then create two files message.txt:

message.txt

login.xyz wants you to sign in with your Ethereum account:

0xfA151B5453CE69ABf60f0dbdE71F6C9C5868800E

Sign-In With Ethereum Example Statement

URI: https://login.xyz

Nonce: ToTaLLyRanDOM

Issued At: 2021-12-17T00:38:39.834Z

signature.txt:

signature.txt

0x8d1327a1abbdf172875e5be41706c50fc3bede8af363b67aefbb543d6d082fb76a22057d7cb6d668ceba883f7d70ab7f1dc015b76b51d226af9d610fa20360ad1c

then run

$ iex -S mix

Once in iex, you can then run the following to see the result:

iex> {:ok, msg} = File.read("./message.txt")

...

iex> {:ok, sig} = File.read("./signature.txt")

iex> Siwe.parse_if_valid(String.trim(msg), String.trim(sig))

{:ok, %{

  __struct__: Siwe,

  address: "0xfA151B5453CE69ABf60f0dbdE71F6C9C5868800E",

  chain_id: "1",

  domain: "login.xyz",

  expiration_time: nil,

  issued_at: "2021-12-17T00:38:39.834Z",

  nonce: "ToTaLLyRanDOM",

  not_before: nil,

  request_id: nil,

  resources: [],

  statement: "Sign-In With Ethereum Example Statement",

  uri: "https://login.xyz",

  version: "1"

}}

Any valid SIWE message and signature pair can be substituted.The functions described below can also be tested with msg, sig, or a value set to the result Siwe.parse_if_valid.

msg

sig

Siwe.parse_if_valid

Sign-In with Ethereum can be installed as a hex. For more information and package information, click

hex

# Ruby

LibrariesRubyA Ruby implementation of EIP-4361: Sign In With Ethereum.PreviousPythonNextRailsLast updated 3 years ago

A Ruby implementation of EIP-4361: Sign In With Ethereum.

The Ruby implementation of Sign-In with Ethereum can be found here:

Additional packages may be required to install the gem:

brew install automake openssl libtool pkg-config gmp libffi

sudo apt-get install build-essential automake pkg-config libtool \

                     libffi-dev libssl-dev libgmp-dev python-dev

After installing any required dependencies SIWE can be easily installed with:

gem install siwe

SIWE provides a Message class which implements EIP-4361.

Message

require 'siwe'

require 'time'

# Only the mandatory arguments

Siwe::Message.new("domain.example", "0x9D85ca56217D2bb651b00f15e694EB7E713637D4", "some.uri", "1")

# Complete SIWE message with default values

Siwe::Message.new("domain.example", "0x9D85ca56217D2bb651b00f15e694EB7E713637D4", "some.uri", "1", {

                                   issued_at: Time.now.utc.iso8601,

                                   statement: "Example statement for SIWE",

                                   nonce: Siwe::Util.generate_nonce,

                                   chain_id: "1",

                                   expiration_time: "",

                                   not_before: "",

                                   request_id: "",

                                   resources: []

                                 })

To parse from EIP-4361 you have to use Siwe::Message.from_message

Siwe::Message.from_message

Siwe::Message.from_message "domain.example wants you to sign in with your Ethereum account:\n0x9D85ca56217D2bb651b00f15e694EB7E713637D4\n\nExample statement for SIWE\n\nURI: some.uri\nVersion: 1\nChain ID: 1\nNonce: k1Ne4KWzBHYEFQo8\nIssued At: 2022-02-03T20:06:19Z"

Messages can be parsed to and from JSON strings, using Siwe::Message.from_json_string and Siwe::Message.to_json_string respectively:

Siwe::Message.from_json_string

Siwe::Message.to_json_string

Siwe::Message.from_json_string "{\"domain\":\"domain.example\",\"address\":\"0x9D85ca56217D2bb651b00f15e694EB7E713637D4\",\"uri\":\"some.uri\",\"version\":\"1\",\"chain_id\":\"1\",\"nonce\":\"k1Ne4KWzBHYEFQo8\",\"issued_at\":\"2022-02-03T20:06:19Z\",\"statement\":\"Example statement for SIWE\",\"expiration_time\":\"\",\"not_before\":\"\",\"request_id\":\"\",\"resources\":[]}"

Siwe::Message.new("domain.example", "0x9D85ca56217D2bb651b00f15e694EB7E713637D4", "some.uri", "1").to_json_string

Verification and authentication is performed via EIP-191, using the address field of the SiweMessage as the expected signer. The validate method checks message structural integrity, signature address validity, and time-based validity attributes.

begin

    message.validate(signature) # returns true if valid throws otherwise

rescue Siwe::ExpiredMessage

    # Used when the message is already expired. (Expires At < Time.now)

rescue Siwe::NotValidMessage

    # Used when the message is not yet valid. (Not Before > Time.now)

rescue Siwe::InvalidSignature

    # Used when the signature doesn't correspond to the address of the message.

Siwe::Message instances can also be serialized as their EIP-4361 string representations via the Siwe::Message.prepare_message method:

Siwe::Message

Siwe::Message.prepare_message

Siwe::Message.new("domain.example", "0x9D85ca56217D2bb651b00f15e694EB7E713637D4", "some.uri", "1").prepare_message

Parsing and verifying a Siwe::Message:

    message = Siwe::Message.from_message "https://example.com wants you to sign in with your Ethereum account:\n0xA712a0AFBFA8656581BfA96352c9EdFc519e9cad\n\n\nURI: https://example.com\nVersion: 1\nChain ID: 1\nNonce: 9WrH24z8zpiYOoBQ\nIssued At: 2022-02-04T15:52:03Z"

    message.validate "aca5e5649a357cee608ecbd1a8455b4143311381636b88a66ec7bcaf64b3a4743ff2c7cc18501a3401e182f79233dc73fc56d01506a6098d5e7e4d881bbb02921c"

    puts "Congrats, your message is valid"

Sign-In with Ethereum can be found on RubyGems. For more information and package information, click

RubyGems

# Go

LibrariesGoA Go implementation of EIP-4361: Sign In With Ethereum.PreviousRailsNextDiscourseLast updated 3 years ago

A Go implementation of EIP-4361: Sign In With Ethereum.

The Go implementation of Sign-In with Ethereum can be found here:

SIWE can be easily installed in any Go project by running:

go get -u github.com/spruceid/siwe-go

SIWE exposes a Message struct which implements EIP-4361.

Parsing is done via the siwe.ParseMessage function:

siwe.ParseMessage

var message *siwe.Message

var err error

message, err = siwe.ParseMessage(messageStr)

The function will return a nil pointer and an error if there was an issue while parsing.

Verification and Authentication is performed via EIP-191, using the address field of the Message as the expected signer. This returns the Ethereum public key of the signer:

var publicKey *ecdsa.PublicKey

publicKey, err = message.VerifyEIP191(signature)

The time constraints (expiry and not-before) can also be validated, at current or particular times:

if message.ValidNow() {

  // ...

// equivalent to

if message.ValidAt(time.Now().UTC()) {

Combined verification of time constraints and authentication can be done in a single call with verify:

// Optional nonce variable to be matched against the

// built message struct being verified

var optionalNonce *string

// Optional timestamp variable to verify at any point

// in time, by default it will use `time.Now()`

var optionalTimestamp *time.Time

publicKey, err = message.Verify(signature, optionalNonce, optionalTimestamp)

// If you won't be using nonce matching and want

// to verify the message at the current time, it's

// safe to pass `nil` in both arguments

publicKey, err = message.Verify(signature, nil, nil)

Message instances can also be serialized as their EIP-4361 string representations via the String method:

String

fmt.Printf("%s", message.String())

To sign messages directly from Go code, you will need to do it like shown below to correctly follow the personal_sign format:

personal_sign

func signHash(data []byte) common.Hash {

	msg := fmt.Sprintf("\x19Ethereum Signed Message:\n%d%s", len(data), data)

	return crypto.Keccak256Hash([]byte(msg))

func signMessage(message string, privateKey *ecdsa.PrivateKey) ([]byte, error) {

	sign := signHash([]byte(message))

	signature, err := crypto.Sign(sign.Bytes(), privateKey)

	if err != nil {

		return nil, err

	}

	signature[64] += 27

	return signature, nil

}

# Discourse

IntegrationsDiscourseA Discourse plugin to enable Sign-In with Ethereum as an authentication method.PreviousGoNextNextAuth.jsLast updated 1 year ago

A Discourse plugin to enable Sign-In with Ethereum as an authentication method.

Last updated 1 year ago

Overview

Discourse is an open-source discussion platform used for most crypto governances and projects to discuss proposals, updates, and research. The following is a quick guide on how to add Sign-In with Ethereum to your existing Discourse.

Note

This guide is currently compatible with . The discussion about the issues with other builds can be followed .

The Sign-In with Ethereum plugin still requires users to enter an email to associate with their accounts after authenticating for the first time. If the user owns an ENS address, it will be the default selected username. Once an email address is associated, users can then sign in using the SIWE option at any time.

Access your containerâ€™s app.yml file (present in /var/discourse/containers/)

app.yml

/var/discourse/containers/

cd /var/discourse

nano containers/app.yml

Add the pluginâ€™s repository URL to your containerâ€™s app.yml file:

hooks:

  before_code:                             # <-- added

    - exec:                                # <-- added

        cmd:                               # <-- added

          - gem install rubyzip            # <-- added

  after_code:

    - exec:

      cd: $home/plugins

      cmd:

        - sudo -E -u discourse git clone https://github.com/discourse/docker_manager.git

        - sudo -E -u discourse git clone https://github.com/spruceid/discourse-siwe-auth.git   # <-- added

Follow the existing format of the docker_manager.git line; if it does not contain sudo -E -u discourse then insert - git clone https://github.com/spruceid/discourse-siwe-auth.git.

docker_manager.git

sudo -E -u discourse

- git clone https://github.com/spruceid/discourse-siwe-auth.git

Rebuild the container:

./launcher rebuild app

To disable it either remove the plugin or uncheck discourse siwe enabled at (Admin Settings -> Plugins -> discourse-siwe -> discourse siwe enabled ).

discourse siwe enabled

Admin Settings -> Plugins -> discourse-siwe -> discourse siwe enabled

By default, a statement is added to the messages: Sign-in to Discourse via Ethereum. To edit this statement access the settings (same as before) and update it.

To install and enable the plugin on your self-hosted Discourse use the :

This plugin uses the newest Web3Modal v2, in order to use it you need to create a free project id at  and configure it in the plugin.

# NextAuth.js

IntegrationsNextAuth.jsA complete open source authentication solution.PreviousDiscourseNextAuth0Last updated 2 years ago

A complete open source authentication solution.

is an easy-to-implement, full-stack (client/server) open-source authentication library originally designed for  and serverless applications.

The library provides the ability to set up a custom credential provider, which we can take advantage of in order to authenticate users using their existing Ethereum wallet via Sign-In with Ethereum (EIP-4361).

The complete example can be found .

First clone the official NextAuth.js example using your terminal:

git clone https://github.com/nextauthjs/next-auth-example

Then, switch to the project directory:

cd next-auth-example

After cloning, modify the given .env.local.example file, and populate it with the following variables:

.env.local.example

NEXTAUTH_URL=http://localhost:3000

NEXTAUTH_SECRET=somereallysecretsecret

Note: After this, rename the file to .env.local. This example will be routed to http://localhost:3000.

.env.local

yarn add siwe@beta ethers wagmi

Now, modify pages/_app.tsx to inject the WagmiProvider component:

pages/_app.tsx

WagmiProvider

import { Session } from "next-auth"

import { SessionProvider } from "next-auth/react"

import type { AppProps } from "next/app"

import { WagmiConfig, createClient, configureChains, chain } from "wagmi"

import { publicProvider } from "wagmi/providers/public"

import "./styles.css"

export const { chains, provider } = configureChains(

  [chain.mainnet, chain.polygon, chain.optimism, chain.arbitrum],

  [publicProvider()]

)

const client = createClient({

  autoConnect: true,

  provider,

})

// Use of the <SessionProvider> is mandatory to allow components that call

// `useSession()` anywhere in your application to access the `session` object.

export default function App({

  Component,

  pageProps,

}: AppProps<{

  session: Session;

}>) {

  return (

    <WagmiConfig client={client}>

      <SessionProvider session={pageProps.session} refetchInterval={0}>

        <Component {...pageProps} />

      </SessionProvider>

    </WagmiConfig>

  )

We're going to now add the provider that will handle the message validation. Since it's not possible to sign in using the default page, the original provider should be removed from the list of providers before rendering. Modify pages/api/auth/[...nextauth].ts with the following:

pages/api/auth/[...nextauth].ts

import NextAuth from "next-auth"

import CredentialsProvider from "next-auth/providers/credentials"

import { getCsrfToken } from "next-auth/react"

import { SiweMessage } from "siwe"

// For more information on each option (and a full list of options) go to

// https://next-auth.js.org/configuration/options

export default async function auth(req: any, res: any) {

  const providers = [

    CredentialsProvider({

      name: "Ethereum",

      credentials: {

        message: {

          label: "Message",

          type: "text",

          placeholder: "0x0",

        signature: {

          label: "Signature",

      },

      async authorize(credentials) {

        try {

          const siwe = new SiweMessage(JSON.parse(credentials?.message || "{}"))

          const nextAuthUrl = new URL(process.env.NEXTAUTH_URL)

          const result = await siwe.verify({

            signature: credentials?.signature || "",

            domain: nextAuthUrl.host,

            nonce: await getCsrfToken({ req }),

          })

          if (result.success) {

            return {

              id: siwe.address,

          }

          return null

        } catch (e) {

    }),

  const isDefaultSigninPage =

    req.method === "GET" && req.query.nextauth.includes("signin")

  // Hide Sign-In with Ethereum from default sign page

  if (isDefaultSigninPage) {

    providers.pop()

  return await NextAuth(req, res, {

    // https://next-auth.js.org/configuration/providers/oauth

    providers,

    session: {

      strategy: "jwt",

    },

    secret: process.env.NEXTAUTH_SECRET,

    callbacks: {

      async session({ session, token }: { session: any; token: any }) {

        session.address = token.sub

        session.user.name = token.sub

        session.user.image = "https://www.fillmurray.com/128/128"

        return session

  })

The default sign-in page can't be used because there is no way to hook wagmi to listen for clicks on the default sign-in page provided by next-auth, so a custom page must be created to handle the sign-in flow. Create pages/siwe.tsx and populate it with the following:

pages/siwe.tsx

import { getCsrfToken, signIn, useSession } from "next-auth/react"

import { useAccount, useConnect, useNetwork, useSignMessage } from "wagmi"

import Layout from "../components/layout"

import { InjectedConnector } from 'wagmi/connectors/injected'

import { useEffect, useState } from "react"

function Siwe() {

  const { signMessageAsync } = useSignMessage()

  const { chain } = useNetwork()

  const { address, isConnected } = useAccount()

  const { connect } = useConnect({

    connector: new InjectedConnector(),

  const { data: session, status } = useSession()

  const handleLogin = async () => {

      const callbackUrl = "/protected"

      const message = new SiweMessage({

        domain: window.location.host,

        address: address,

        statement: "Sign in with Ethereum to the app.",

        uri: window.location.origin,

        version: "1",

        chainId: chain?.id,

        nonce: await getCsrfToken(),

      })

      const signature = await signMessageAsync({

        message: message.prepareMessage(),

      signIn("credentials", {

        message: JSON.stringify(message),

        redirect: false,

        signature,

        callbackUrl,

    } catch (error) {

      window.alert(error)

  useEffect(() => {

    console.log(isConnected);

    if (isConnected && !session) {

      handleLogin()

  }, [isConnected])

    <Layout>

      <button

        onClick={(e) => {

          e.preventDefault()

          if (!isConnected) {

            connect()

          } else {

            handleLogin()

        }}

      >

        Sign-in

      </button>

    </Layout>

export async function getServerSideProps(context: any) {

  return {

    props: {

      csrfToken: await getCsrfToken(context),

Siwe.Layout = Layout

export default Siwe

Modify pages/styles.css by appending the following CSS:

pages/styles.css

button {

  margin: 0 0 0.75rem 0;

  text-decoration: none;

  padding: 0.7rem 1.4rem;

  border: 1px solid #346df1;

  background-color: #346df1;

  color: #fff;

  font-size: 1rem;

  border-radius: 4px;

  transition: all 0.1s ease-in-out;

  font-weight: 500;

  position: relative;

button:hover {

  cursor: pointer;

  box-shadow: inset 0 0 5rem rgb(0 0 0 / 20%);

Finally, modify the components/header.tsx in order to clean it up and add a SIWE tab to navigate to the newly created page:

components/header.tsx

import { signOut, useSession } from "next-auth/react"

import Link from "next/link"

import { useDisconnect } from "wagmi"

import styles from "./header.module.css"

// The approach used in this component shows how to build a sign in and sign out

// component that works on pages which support both client and server side

// rendering, and avoids any flash incorrect content on initial page load.

export default function Header() {

  const loading = status === "loading"

  const { disconnect } = useDisconnect()

    <header>

      <noscript>

        <style>{`.nojs-show { opacity: 1; top: 0; }`}</style>

      </noscript>

      <div className={styles.signedInStatus}>

        <p

          className={`nojs-show ${!session && loading ? styles.loading : styles.loaded}`}

        >

          {!session && (

            <>

              <span className={styles.notSignedInText}>

                You are not signed in

              </span>

            </>

          )}

          {session?.user && (

              {session.user.image && (

                <span

                  style={{ backgroundImage: `url('${session.user.image}')` }}

                  className={styles.avatar}

                />

              )}

              <span className={styles.signedInText}>

                <small>Signed in as</small>

                <br />

                <strong>{session.user.email ?? session.user.name}</strong>

              <a

                href={`/api/auth/signout`}

                className={styles.button}

                onClick={(e) => {

                  e.preventDefault()

                  disconnect()

                  signOut()

                }}

              >

                Sign out

              </a>

        </p>

      </div>

      <nav>

        <ul className={styles.navItems}>

          <li className={styles.navItem}>

            <Link href="/">

              Home

            </Link>

          </li>

            <Link href="/siwe">

              SIWE

        </ul>

      </nav>

    </header>

Run the application using the following commands:

yarn install

yarn dev

Navigate to localhost:3000 - now you are now ready to Sign-In with Ethereum. Just click the SIWE link in the header, hit the "Sign-In with Ethereum" button, sign the message, and you are now authenticated.

localhost:3000

SIWE

If you face the following error:

Error: Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.

go to components/footer.tsx and remove the <a> tag from Policy at line 21.

components/footer.tsx

Next Add siwe, ethers, and wagmi as dependencies. In this example, we're using , which is a well-known React hooks library for Ethereum. In your terminal, navigate to the project we originally cloned and add the dependencies via the following commands:

wagmi

# Auth0

IntegrationsAuth0Auth0 marketplace integrationPreviousNextAuth.jsNextSecurity ConsiderationsLast updated 3 years ago

Auth0 marketplace integration

Auth0 is the leading platform for authentication and authorization for web2 applications and services in retail, publishing, B2B SaaS, and more. Sign-In with Ethereum was recently integrated into Auth0 by Spruce in collaboration with Auth0 and the Auth0 Lab team.

The integration uses the open-source OpenID Connect Identity Provider (hosted under oidc.login.xyz) for Sign-In with Ethereum implementation in Rust:

The entire workflow involved can be seen in this activity diagram:

After hitting the login button, users are redirected to the Auth0 flow and Sign-In with Ethereum using the provided interface. Once authenticated, users are then redirected back to the application where they can view their gallery.

As part of the login, the application also resolves the user's ENS name if present. Users can then return to the main splash screen or disconnect from the application.

An example application to show off the authentication flow can be found . The example features a mock NFT gallery website where users can Sign-In with Ethereum, and their NFT holdings are resolved via the OpenSea API once authenticated.

# ðŸ”“Security Considerations

Additional SupportðŸ”“Security ConsiderationsSign-In with Ethereum Security ConsiderationsWhen using SIWE, implementers should aim to mitigate security issues on both the client and server. This is a growing collection of best practices for implementers, but no security checklist can ever be truly complete.Message Generation and ValidationWhen processing a SIWE message on the backend, it must be validated as per specified in EIP-4361. This is achieved in the quickstart guide by creating the entire SIWE message on the backend, and verifying that the message signed was identical with a valid signature.However, some implementers may choose not to generate the signing message entirely on the server-side, and instead, have the frontend request specific field values from the server or otherwise agree on a value generation method. The backend then asserts that the received signed message matches what is expected during verification.(WIP) Notes on select fields and their value selection:nonce. To prevent replay attacks, a nonce should be selected with sufficient entropy for the use case, and the server should assert that the nonce matches the expected value. In some systems, the server and client may agree to use a nonce derived from a recent block hash or system time, reducing server interaction.domain. Wallets conforming to EIP-4361 are able to check for (or even generate) correct domain bindings to prevent phishing attacks, i.e., that the website "example.org" is indeed securely serving the SIWE message beginning with "example.org wants you to sign in with..."PreviousAuth0NextENS Profile ResolutionLast updated 3 years ago

Sign-In with Ethereum Security Considerations

When using SIWE, implementers should aim to mitigate security issues on both the client and server. This is a growing collection of best practices for implementers, but no security checklist can ever be truly complete.

When processing a SIWE message on the backend, it must be validated as per specified in EIP-4361. This is achieved in the quickstart guide by creating the entire SIWE message on the backend, and verifying that the message signed was identical with a valid signature.

However, some implementers may choose not to generate the signing message entirely on the server-side, and instead, have the frontend request specific field values from the server or otherwise agree on a value generation method. The backend then asserts that the received signed message matches what is expected during verification.

(WIP) Notes on select fields and their value selection:

nonce. To prevent replay attacks, a nonce should be selected with sufficient entropy for the use case, and the server should assert that the nonce matches the expected value. In some systems, the server and client may agree to use a nonce derived from a recent block hash or system time, reducing server interaction.

domain. Wallets conforming to EIP-4361 are able to check for (or even generate) correct domain bindings to prevent phishing attacks, i.e., that the website "example.org" is indeed securely serving the SIWE message beginning with "example.org wants you to sign in with..."

Last updated 3 years ago

# ENS Profile Resolution

Additional SupportENS Profile ResolutionResolve ENS Profiles for users signing into a servicePreviousSecurity ConsiderationsNextCommunity HighlightsLast updated 3 years ago

Resolve ENS Profiles for users signing into a service

>= v5.5.3

The user's linked  (ENS) information can be retrieved after their Ethereum address is known. After the user connects with their wallet but before they Sign-In with Ethereum, ENS information can be used to provide additional context to the user about which account is connected.

If the user completes Sign-In with Ethereum to authenticate, the ENS data resolved from their Ethereum address may be used as part of the authenticated session, such as checking that the address's default ENS name is alisha.eth before granting access to certain pages or resources.

alisha.eth

The information can be retrieved using :

import { ethers } from 'ethers';

const provider = new ethers.providers.EtherscanProvider()

const address = '0x9297A132AF2A1481441AB8dc1Ce6e243d879eaFD'

const ensName = await provider.lookupAddress(address)

const ensAvatarUrl = await provider.getAvatar(ensName)

const ensResolver = await provider.getResolver(ensName)

// You can fetch any key stored in their ENS profile.

const twitterHandle = await ensResolver.getText('com.twitter')

The user's Avatar location can be resolved using ensResolver.getText, butgetAvatar is recommended as it resolves NFT avatars to a URL.

ensResolver.getText

getAvatar

The EtherscanProvider above uses a shared API key and is therefore rate-limited. For a production application, we strongly recommend using a new API key with  or .

EtherscanProvider

# Community Highlights

Additional SupportCommunity HighlightsCommunity-Driven Sign-In with Ethereum Guides and BuildsPreviousENS Profile ResolutionNextOIDC ProviderLast updated 2 years ago

Community-Driven Sign-In with Ethereum Guides and Builds

The following is a list of libraries, guides, and more made available by the Sign-In with Ethereum community. Note - some of the listed items may have not yet undergone formal security audits, and may also be experimental or alpha stage.

(Django)

(C#)

(Next.js + Iron-Session)

(WordPress)

(Serverless SIWE)

(Fastify SIWE)

(Java)

# OIDC Provider

ServersOIDC ProviderAn OpenID Connect Identity Provider for Sign-In with EthereumPreviousCommunity HighlightsNextDeployment GuideLast updated 2 years ago

An OpenID Connect Identity Provider for Sign-In with Ethereum

Many organizations want to consolidate the Sign-In with Ethereum workflow to a single identity service (Identity Provider or IdP) that could be used to access all their federated services (Relying Parties or RPs) using  to forward the user's session. This reduces overhead and mitigates security risks by consolidating authentication to one protected site instead of several, especially in complex IT systems that have many services for their users to access.

The OIDC Provider implementation of Sign-In with Ethereum can be found here:

Currently, two runtime modes are supported: (1) a standalone executable (using Axum and Redis) and (2) a WASM module within a Cloudflare Worker. Both are built from the same codebase, specializing at build time. Compilation with a cargo target of wasm32 will build for Cloudflare Worker deployments.

cargo

wasm32

For convenience, a fully deployed and hosted version of the OpenID Connect Provider (OP) is available under . SeeHosted OIDC Provider for more information.

# Deployment Guide

ServersOIDC ProviderDeployment GuideDeploying the self-hosted SIWE OIDC ProviderPreviousOIDC ProviderNextHosted OIDC ProviderLast updated 3 years ago

Deploying the self-hosted SIWE OIDC Provider

First, ensure  is installed and ready to interact with Cloudflare Worker API. You will need a Cloudflare account. Clone the project repository, and setup your Cloudflare Worker project after authenticating with Wrangler.

git clone https://github.com/spruceid/siwe-oidc

cd siwe-oidc

wrangler login

wrangler whoami  # account_id

wrangler kv:namespace create SIWE_OIDC  # kv_namespaces entry

Use the example Wrangler configuration file as a starting template:

cp wrangler_example.toml wrangler.toml

Populate the following fields for the Cloudflare Worker:

account_id: the Cloudflare account ID;

account_id

zone_id: (Optional) DNS zone ID; and

zone_id

kv_namespaces: an array of KV namespaces

kv_namespaces

Create and publish the worker:

wrangler publish

The IdP currently only supports having the frontend under the same subdomain as the API. Here is the configuration for Cloudflare Pages:

Build command: cd js/ui && npm install && npm run build;

Build command

cd js/ui && npm install && npm run build

Build output directory: /static; and

Build output directory

/static

Root directory: /. And you will need to add some rules to do the routing between the Page and the Worker. Here are the rules for the Worker (the Page being used as the fallback on the subdomain):

Root directory

/

siweoidc.example.com/s*

siweoidc.example.com/u*

siweoidc.example.com/r*

siweoidc.example.com/a*

siweoidc.example.com/t*

siweoidc.example.com/j*

siweoidc.example.com/.w*

Dependencies

Redis, or a Redis compatible database (e.g. MemoryDB in AWS), is required.

Starting the IdP

The Docker image is available at ghcr.io/spruceid/siwe_oidc:0.1.0. Here is an example usage:

ghcr.io/spruceid/siwe_oidc:0.1.0

docker run -p 8000:8000 -e SIWEOIDC_ADDRESS="0.0.0.0" -e SIWEOIDC_REDIS_URL="redis://redis" ghcr.io/spruceid/siwe_oidc:latest

It can be configured either with the siwe-oidc.toml configuration file, or through environment variables:

siwe-oidc.toml

SIWEOIDC_ADDRESS is the IP address to bind to.

SIWEOIDC_ADDRESS

SIWEOIDC_REDIS_URL is the URL to the Redis instance.

SIWEOIDC_REDIS_URL

SIWEOIDC_BASE_URL is the URL you want to advertise in the OIDC configuration (e.g. https://oidc.example.com).

SIWEOIDC_BASE_URL

https://oidc.example.com

SIWEOIDC_RSA_PEM is the signing key, in PEM format. One will be generated if none is provided.

SIWEOIDC_RSA_PEM

The current flow is very basic -- after the user is authenticated you will receive an Ethereum address as the subject (sub field).

sub

For the core OIDC information, it is available under /.well-known/openid-configuration.

/.well-known/openid-configuration

OIDC Conformance Suite:

wrangler dev

At the moment it's not possible to use it end-to-end with the frontend as they need to share the same host (i.e. port), unless using a local load-balancer.

A Docker Compose is available to test the IdP locally with Keycloak.

You will first need to run:

docker-compose up -d

And then edit your /etc/hosts to have siwe-oidc point to 127.0.0.1. This is so both your browser, and Keycloak, can access the IdP.

/etc/hosts

siwe-oidc

127.0.0.1

In Keycloak, you will need to create a new IdP. You can use http://siwe-oidc:8000/.well-known/openid-configuration to fill the settings automatically. As for the client ID/secret, you can use sdf/sdf.

http://siwe-oidc:8000/.well-known/openid-configuration

sdf

ðŸŸ¨ (25/29, and 10 skipped)  (email scope skipped, profile scope partially supported, ACR, prompt=none and request URIs yet to be supported);

profile

prompt=none

ðŸŸ© ;

ðŸŸ§ .

You can now use .

wrangler

# Hosted OIDC Provider

ServersOIDC ProviderHosted OIDC ProviderUsing the hosted SIWE OIDC ProviderPreviousDeployment GuideNextSIWE OverviewLast updated 1 year ago

Using the hosted SIWE OIDC Provider

We deployed an OpenID Connect Provider (OP) with SIWE support hosted under . This deployment is supported by the ENS DAO, under  in order to have a DAO-governed OpenID Connect Provider.

Developers will be able to use a standard OIDC client to connect to the hosted OP. Please see our  for more information about supported OIDC features.

To use the hosted OP, developers are typically interested in the following steps:

Retrieving the OP configuration.

Registering the OIDC client with the OP.

Using the OP configuration to configure the OIDC client.

The OP supports the OpenID Connect Provider Configuration specification as per  . To fetch the OP configuration which is required for configuring OIDC clients, developers can make a GET HTTPS request to the following endpoint as follows:

curl https://oidc.signinwithethereum.org/.well-known/openid-configuration

This will result in the latest OP configuration object that provides information about supported OIDC flows, endpoints, public keys, signing algorithm, client authentication types, etc. as follows:

   "issuer":"https://oidc.signinwithethereum.org/",

   "authorization_endpoint":"https://oidc.signinwithethereum.org/authorize",

   "token_endpoint":"https://oidc.signinwithethereum.org/token",

   "userinfo_endpoint":"https://oidc.signinwithethereum.org/userinfo",

   "jwks_uri":"https://oidc.signinwithethereum.org/jwk",

   "registration_endpoint":"https://oidc.signinwithethereum.org/register",

   "scopes_supported":[

      "openid",

      "profile"

   ],

   "response_types_supported":[

      "code",

      "id_token",

      "token id_token"

   "subject_types_supported":[

      "pairwise"

   "id_token_signing_alg_values_supported":[

      "RS256"

   "userinfo_signing_alg_values_supported":[

   "token_endpoint_auth_methods_supported":[

      "client_secret_basic",

      "client_secret_post",

      "private_key_jwt"

   "claims_supported":[

      "sub",

      "aud",

      "exp",

      "iat",

      "iss",

      "preferred_username",

      "picture"

   "op_policy_uri":"https://oidc.signinwithethereum.org/legal/privacy-policy.pdf",

   "op_tos_uri":"https://oidc.signinwithethereum.org/legal/terms-of-use.pdf"

To use the hosted OIDC server it is required to register the application as an OIDC client using the OIDC client registration of oidc.signinwithethereum.org. Currently, no user interface for OIDC client registration is supported. For that reason, developers will need to use the REST API.

To register a new OIDC client, the following request has to be adapted:

curl -X POST https://oidc.signinwithethereum.org/register \

   -H 'Content-Type: application/json' \

   -d '{"redirect_uris": ["https://<your.comaind>/cb"]}'

The OIDC server needs to know whether the user is allowed to be redirected to the URI in the OIDC request after authentication for the specific OIDC client. This must be configured through the redirect_uris parameter.

redirect_uris

The response will be a OIDC client metadata object that contains the client_id and client_secret that have to be used to retrieve the OIDC tokens from the token endpoint. Developers have to make sure that those parameters have to be kept secret.

client_id

client_secret

The following is an example response:

    "client_id": "9b49de48-d198-47e7-afff-7ee26cbcbc95",

    "client_secret": "er...",

    "registration_access_token": "2a...",

    "registration_client_uri": "https://oidc.signinwithethereum.org/client/9b49de48-d198-47e7-afff-7ee26cbcbc95",

    "redirect_uris": ["https://<your.domain>/cb"]

A client can then be updated or deleted using the registration_client_uri with the registration_access_token as a Bearer token.

registration_client_uri

registration_access_token

A variety of  are available. In particular, we make use of the following:

- client_name;

- logo_uri; and

- client_uri.

client_name

logo_uri

client_uri.

# SIWE Overview

General InformationSIWE OverviewSign-In with Ethereum - For Web2 and Web3PreviousHosted OIDC ProviderNextEIP-4361Last updated 3 years ago

Sign-In with Ethereum - For Web2 and Web3

Todayâ€™s login experiences rely on accounts controlled by centralized identity providers, for-profit behemoths like Google, Facebook, and Apple. Identity providers often have sole discretion over the existence and use of usersâ€™ digital identities across the web, fundamentally at odds with the best interest of users.

The Ethereum Foundation and Ethereum Name Service (ENS) put forward a  for Sign-in with Ethereum in 2021, which would enable users to use their Ethereum accounts to access web services instead of accounts owned by large corporations.

The Ethereum ecosystem already has tens of millions of monthly active wallet users signing with their cryptographic keys for financial transactions, community governance, and more.

The security of these wallets has been proven across billions of dollars of digital assets at stake--not theoretical security, but real tests in production. These secure wallets can also be used to sign in to Web2 services.

Sign-In with Ethereum describes how Ethereum accounts authenticate with off-chain services by signing a standard message format parameterized by scope, session details, and security mechanisms (e.g., a nonce).

Already, many services support workflows to authenticate Ethereum accounts using message signing, such as establishing a cookie-based web session which can manage privileged metadata about the authenticating address.

For Web2, this is an opportunity to give users control over their identifiers and slowly introduce their dedicated user bases to Web3. By providing a strict specification that can be followed along with any necessary tooling to ease any integration concerns, Sign-In with Ethereum has a chance at truly transforming the way in which individuals interact with apps and services.

For Web3, this is an opportunity to standardize the sign-in workflow and improve interoperability across existing services, while also providing wallet vendors a reliable method to identify signing requests as Sign-In with Ethereum requests for improved UX.

# Review of Related EIPs

General InformationSIWE OverviewReview of Related EIPsA review of existing EIPs that helped shape EIP-4361, Sign-In with EthereumPreviousEIP-4361NextSIWE Code of ConductLast updated 3 years ago

A review of existing EIPs that helped shape EIP-4361, Sign-In with Ethereum

Ethereum Improvement Proposals, or EIPs, are "" that include specifications for developers, and start typically with drafts that encourage a feedback cycle for the greater community. Part of the research in creating EIP-4361 necessitated an investigation into previous EIPs that sought to standardize the way decentralized identity is managed using Ethereum, as well as different ways of signing data.

EIP-191 is a specification about how to handle signed data in Ethereum contracts. It produces human-readable messages and is simple to implement by prefixing a custom message with an invariable prefix prior to presenting it to wallet users for interactive signing.

Originally, EIP-191 was a response to prevent pre-signed transactions originating from multisig wallets from being reused by multisig wallets with the same members.

It consists of the following format for signed_data:

signed_data:

0x19 <1 byte version> <version specific data> <data to sign>

In practice, it is prefixed with: "\x19Ethereum Signed Message:\n" + len(message).

"\x19Ethereum Signed Message:\n" + len(message)

Additionally, signed_data could never be an Ethereum transaction, because it cannot be one RLP-structure, but a 1-byte RLP payload followed by something else.

signed_data

EIP-712 is a standard for the hashing and signing of typed structured data as opposed to just bytestrings. At the core of EIP-712 is the need to sign more complex messages in order to have safer and deeper interactions with decentralized applications.

Another goal for EIP-712 was to improve the usability of off-chain message signing for use on-chain in order to save gas and reduce the number of on-chain transactions.

EIP-725 is an identity standard proposed in order to describe proxy smart contracts that can be controlled by multiple keys and other contracts. An associated EIP (735) enables the addition and removal of claims to an ERC-725 smart contract.

EIP-725 was an early attempt at enabling self-sovereign identity on Ethereum, which involved the deployment of a smart contract that enabled the association of multiple keys with an identity, included execute and approve methods that allowed it to be used as a proxy, and attempted to forge the building blocks for access control lists through those contracts.

execute

approve

EIP-735 is a standard for a claim holder interface to allow dapps and smart contracts to check claims about a claim holder (EIP-725). Claims must first be requested and issued by an issuer that signs a message containing the identityâ€™s address, the claim topic, and additional data. The data is then stored on-chain in the identity ownerâ€™s smart contract.

EIP-780 defines an Ethereum Claims Registry to support decentralized identity on Ethereum and provides a central point of reference for on-chain claims. The Ethereum Claims Registry is a smart contract that can be commonly used by any account and provides an interface for adding, receiving, and removing claims. In this scenario, claims are issued from an issuer to a subject with a key.

Additionally, off-chain claims can be made when an issuer signs data, encodes it into a JWT, and the JWT can later be verified. These off-chain claims can eventually be anchored on-chain via a form of â€˜badgesâ€™ system which differs from using traditional NFTs because they are non-transferable.

EIP-1056 is a specification for an identity system for Ethereum compliant with the decentralized identifiers standard (DID). It is meant to be paired with EIP-780, which defines an Ethereum Claims Registry to be used for the issuance and verification of claims.

EIP-1056 defines all existing Ethereum accounts as valid identities based solely on their existence as a public / private keypair. All identities can assign delegates that are valid for a specified amount of time and can be revocable or not. Additionally, delegates can be used on or off-chain to sign JWTs, Ethereum transactions, and arbitrary data.

This EIP was a response to EIP-725, due to EIP-725 requiring the creation of a smart contract and not being free for the end-user. The specification additionally accounts for key rotation without changing the primary identifier of the identity.

EIP-1102 proposes a more consentful and privacy-preserving way to expose metadata from an Ethereum user's wallet by prompting the user to accept the egressing data prior to its release. This strategy has already been implemented by MetaMask for user wallet connections.

EIP-1115 defines an authentication mechanism for dapps to authenticate users. In the specification, an HTTP server is set up by a user (called a DAuth server) and requires a password and public / private keypair. The user then registers a username on the smart contract that the specification defines by including the public key of the DAuth server and an address.

Logging into a dapp includes the user providing a random string (â€œCodeâ€) to identify the current authentication session, a HashCode, and the username from the smart contract. The dapp will fetch both the public key and server address from the smart contract, and generate a secret string. After that, it will pass the â€œCode,â€ HashCode, username, and secret string to the DAuth serverâ€™s verification endpoint.

The DAuth server will fetch the hash of the password and private key from its database related to the username in the request. After validating the HashCode, and attempting to decrypt the cipher, the decrypted value will then be sent to the dapp.

EIP-1271 is a specification that demonstrates a way for contracts to verify if a provided signature is valid when an account in question is a smart contract. This could be in the case of a user using a smart contract-based wallet or a user being part of a multisig wallet.

Smart contracts cannot directly sign messages, so EIP-1271 serves as a guide to implement isValidSignature(hash, signature) on the signing contract that can be called to validate a signature. With the rise of smart contract wallets and DAOs controlled by multi-sigs, these parties require the means to use signed messages to demonstrate the right to move assets, vote, or for other purposes.

isValidSignature(hash, signature)

EIP-1484 provides a different attempt at creating a digital identity standard on Ethereum by proposing an identity management and aggregation framework. Entities in this specification can claim an identity via a singular identity registry smart contract. The goal of this additional specification was to keep it compliant with the EIP-725 and EIP-1056 specifications that already existed.

EIP-1484â€™s aim was to create a protocol layer between the Ethereum blockchain and individual applications that required some form of user identity (tackling identity management and interoperability challenges along the way). This implementation required a global ERC1848 implementation up and running on the network in order to handle and enforce the rules for a global namespace made up of â€œEINsâ€ or Ethereum Identification Numbers.

EIP-1812 defines a method for off-chain verifiable claims built on EIP-712, which can be verified on-chain by smart contracts, state channel implementations, or off-chain libraries. By using ERC-735 and ERC-780 individuals can make claims that live on-chain, but sensitive information is best kept off-chain for GDPR and PII protection purposes.

Additionally, this EIP also recognizes EIP-1056 to provide a method for addresses to assign delete signers so an account can perform an action on behalf of a smart contract. Based on this specification, EIP-712 based state channels can include embeddable claims which are useful for exchanging private claims between parties for regulatory reasons and avoiding posting them on-chain.

EIP-2525 presented a new method of login to the Ethereum blockchain using metadata stored in ENS. EIP-2525â€™s workflow would include an ENS domain retrieval from the user, domain resolution, interpretation of a text entry, an evaluation of the content in the text entry, and lastly, the corresponding object would then be returned to the dapp.

At its core, EIP-2525 seeks to use ENS metadata to standardize across login mechanisms.

EIP-2844 makes JOSE-conformant DID resolution and verificationMethod requests part of ETH RPC (EIP-1474) and standardizes how Ethereum wallets can be queried for DID documents.

EIP-3361 introduces a standard for JSON-RPC calls across wallets and provides an upgrade path for all of todayâ€™s signing methods that are currently splintered. It mentions EIP-1474, eth_sign standardization with prefixed signatures, as where signing became fragmented due to some applications using it and some choosing to keep the older eth_sign behavior pre-EIP-1474.

eth_sign

It seeks to depreciate personal_sign in order to make sure both old and new applications are using the same method.

personal_sign

# SIWE Code of Conduct

General InformationSIWE Code of ConductA code of conduct for public community activity around Sign-In with Ethereum.PreviousReview of Related EIPsLast updated 3 years ago

A code of conduct for public community activity around Sign-In with Ethereum.

The following outlines a code of conduct for the public community-facing interactions around the Sign-In with Ethereum project, including  hosted by Spruce, and the .

Our goal is to create the best environment for the Sign-In with Ethereum standard to flourish across Web2 and Web3. To achieve this, we must have the best technologists, strategists, and community leaders actively involved, building and maintaining an environment of trust which can only exist where each individual is able to enjoy respect and courtesy.

To ensure a common understanding of â€œshowing respect and courtesy to each other,â€ we have adopted the following code of conduct.

The following types of abusive behavior are unacceptable and constitute code of conduct violations:

Harassment - including offensive verbal comments related to gender, sexual orientation, disability, physical appearance, body size, race, or religion, and unwelcome sexual or romantic attention.

Threats - threatening someone verbally or in writing.

Maliciousness - any direct abuse towards other members of the community â€”deliberately attempting to make others feel bad, name-calling, singling out others for derision or exclusion. For example, telling someone they donâ€™t belong at community calls or in the public discussion.

If abusive behavior is witnessed or reported either on the community calls or in the public Discord channel, it will first be evaluated by a member of the Spruce team. If it is deemed inappropriate and in violation of the code of conduct, it will result in a permanent suspension from both the community calls and Discord channel.

All individuals reporting violations of the code of conduct made by other community members will remain anonymous.

The Sign-In with Ethereum code of conduct is available under the terms of the .

This code of conduct draws from and was heavily inspired by the . We hope to create a welcoming space for anyone wishing to participate in helping shape Sign-In with Ethereum.
